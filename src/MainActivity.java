// DO NOT EDIT THIS FILE - it is automatically generated, edit file under project/java dir
// This string is autogenerated by ChangeAppSettings.sh, do not change spaces amount
package com.androthsoft.battle;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.text.InputType;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.view.Window;
import android.view.WindowManager;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.TextView;
import android.widget.EditText;
import android.text.Editable;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.AbsoluteLayout;
import android.widget.FrameLayout;
import android.content.res.Configuration;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.view.View.OnKeyListener;
import android.text.method.TextKeyListener;
import android.text.SpannedString;
import android.provider.Settings.Secure;
import android.view.Gravity;
import android.util.Log;
import android.graphics.Canvas;
import android.graphics.Paint;

import android.content.pm.PackageManager;

import java.util.LinkedList;
import java.io.SequenceInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.File;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.io.BufferedReader;
import java.io.BufferedInputStream;
import java.io.InputStreamReader;

import com.android.vending.licensing.LicenseChecker;
import com.android.vending.licensing.LicenseCheckerCallback;
import com.android.vending.licensing.ServerManagedPolicy;
import com.android.vending.licensing.AESObfuscator;


public class MainActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		try {
			Globals.ApplicationVersion = Integer.toString(this.getPackageManager().getPackageInfo(this.getPackageName(), 0).versionCode);
		} catch (PackageManager.NameNotFoundException e) {
			Globals.ApplicationVersion = "0";

		}


		// fullscreen mode
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
				WindowManager.LayoutParams.FLAG_FULLSCREEN);
		if(Globals.InhibitSuspend)
			getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,
					WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

		System.out.println("libSDL: Creating startup screen");

		setContentView(R.layout.main);

		videoLayout_ = (FrameLayout) findViewById(R.id.videoLayout_);
		layout_ = (LinearLayout) findViewById(R.id.layout_);
		layout2_ = (LinearLayout) findViewById(R.id.layout2_);
		ImageView img = (ImageView) findViewById(R.id.img);
		
		if(mAudioThread == null) // Starting from background (should not happen)
		{
			System.out.println("libSDL.V: Loading libraries");
			LoadLibraries();
			mAudioThread = new AudioThread(this);
			System.out.println("libSDL: Loading settings");
			Settings.Load(this);
		 }

		if( !Settings.settingsChanged )
		{
			//System.out.println("libSDL: 3-second timeout in startup screen");
			class Callback implements Runnable
			{
				MainActivity p;
				Callback( MainActivity _p ) { p = _p; }
				public void run()
				{
					try {
						Thread.sleep(30);
					} catch( InterruptedException e ) {};
					if( Settings.settingsChanged )
						return;
					System.out.println("libSDL: Timeout reached in startup screen, process with downloader");
					p.startDownloader();
				}
			};
			Thread changeConfigAlertThread = null;
			changeConfigAlertThread = new Thread(new Callback(this));
			changeConfigAlertThread.start();
		}
	}
	
	public void setUpStatusLabel()
	{
		MainActivity Parent = this; // Too lazy to rename
		if( Parent.btn_ != null )
		{
			Parent.btn_ = null;
		}
		if( Parent.tv_ == null )
		{
			Parent.tv_ = new TextView(Parent);
			Parent.tv_.setMaxLines(1);
			Parent.tv_.setText(R.string.init);
			Parent.layout2_.addView(Parent.tv_);
		}
	}

	private static final String BASE64_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsaOg0Fx2/UEWQzOJQaB4wkrX5pRjEcLCeGPn101VeazqmtJJGbU3xH+Hpi8+uhygdQcP40EuWR+j8FFQmcKwTrZfKCtZeDvu8+/IgWuaa+JCU4YGNyFDnxaKOpM4reQ3QiaP96KSYLIL7acxCXUnqpyguEkIbuMv9Gdz8zfAeOQQ2P8Zxjsmpj09acxwAFQhvSIzYVhX2DMW6odCA6qfTGnQzIgXf19i7YQLX6m4MM1M6KOmkWDgcDOH2JOIMNN4fm7c3f1Snz74e7qxiuquLwEW7yyqFSh1hepeIXY8isFO/gE97pCTg8cuSrnZaifOAOFvQQx+kA7C2qYhLiHk2QIDAQAB";
	private static final byte[] salt = {
		10, 51, -66, -65, 21,
		52, 45, 11, -120, -3,
		-36, 32, 89, 49, -36,
		77, 25, -26, 39, -98,
	};
	public void startDownloader()
	{
		System.out.println("libSDL: Starting data downloader");
		class Callback implements Runnable
		{
			public MainActivity Parent;
			public void run()
			{
				setUpStatusLabel();
				System.out.println("libSDL: Starting downloader");
				if( Parent.downloader == null )
					Parent.downloader = new DataDownloader(Parent, Parent.tv_);
			}
		}

		Callback cb = new Callback();
		cb.Parent = this;
		if (Globals.ApplicationName.endsWith("Free")) {
			this.runOnUiThread(cb);
		} else {
			class LicenseCallback implements LicenseCheckerCallback {
				Callback cb;
				public void allow() {
					System.out.println("License check passed.");
					Globals.isLicensed = true;
					cb.Parent.runOnUiThread(cb);
				}
				public void dontAllow() {
					System.out.println("License check failed.");
					Globals.isLicensed = false;
					cb.Parent.runOnUiThread(cb);
				}
				public void applicationError(ApplicationErrorCode err) {
					System.out.println("" + err);
					dontAllow();
				}
			}

			LicenseCallback lcb = new LicenseCallback();
			lcb.cb = cb;
			String deviceId = Secure.getString(getContentResolver(), Secure.ANDROID_ID);
			LicenseChecker checker = new LicenseChecker(this, new ServerManagedPolicy(this, new AESObfuscator(salt, getPackageName(), deviceId)), BASE64_PUBLIC_KEY);
			checker.checkAccess(lcb);
		}
	}

	public class WesnothEditText extends EditText {
		public WesnothEditText(Context c) {
			super(c);
			setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
			setSingleLine();

			class myKeyListener implements OnKeyListener 
			{
				MainActivity parent_;
				myKeyListener(MainActivity parent) { parent_ = parent; };
				public boolean onKey(View v, int keyCode, KeyEvent event) 
				{
					if ((event.getAction() == KeyEvent.ACTION_UP) && ((keyCode == KeyEvent.KEYCODE_ENTER)))
					{
						parent_.hideScreenKeyboard(1);
						return true;
					}
					if ((keyCode == KeyEvent.KEYCODE_BACK))
					{
						parent_.hideScreenKeyboard(0);
						return true;
					}
					return false;
				}
			};

			setOnKeyListener(new myKeyListener(MainActivity.this));
			setKeyListener(new TextKeyListener(TextKeyListener.Capitalize.NONE, false));
			setFocusableInTouchMode(true);
			setFocusable(true);
			setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.FILL_PARENT, FrameLayout.LayoutParams.FILL_PARENT, Gravity.NO_GRAVITY));
			setBackgroundDrawable(null);
		}
		@Override
		public boolean onKeyPreIme(int keyCode, KeyEvent event) {
			if (keyboardVisible_ && event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
				KeyEvent.DispatcherState state = getKeyDispatcherState();
				if (state != null) {
					if (event.getAction() == KeyEvent.ACTION_DOWN &&
							event.getRepeatCount() == 0) {
						state.startTracking(event, this);
						return true;
					} else if (event.getAction() == KeyEvent.ACTION_UP &&
							!event.isCanceled() && state.isTracking(event)) {
						hideScreenKeyboard(0);
						return true;
					}
				}
			}
			return super.onKeyPreIme(keyCode, event);
		}
		@Override
		protected void onSizeChanged(int w, int h, int ow, int oh) {
		}
		@Override
		protected void onDraw(Canvas canvas) {
			canvas.save();
			super.onMeasure(
					View.MeasureSpec.makeMeasureSpec(w_, View.MeasureSpec.EXACTLY),
					View.MeasureSpec.makeMeasureSpec(h_, View.MeasureSpec.EXACTLY));
			super.onLayout(true, x_, y_, x_ + w_, y_ + h_);

			canvas.translate(x_, y_);
			Paint p = new Paint();
			p.setARGB(255, 55, 55, 55);
			canvas.drawRect(0, 0, w_, h_, p);
			p.setARGB(255, 188, 176, 136);
			canvas.drawRect(1, 1, w_ - 1, h_ - 1, p);
			p.setARGB(255, 55, 55, 55);
			canvas.drawRect(2, 2, w_ - 2, h_ - 2, p);
			p.setARGB(255, 21, 19, 19);
			canvas.drawRect(3, 3, w_ - 3, h_ - 3, p);

			super.onDraw(canvas);
			canvas.restore();
		}
		@Override
		protected void onLayout(boolean c, int l, int t, int r, int b) {
			int mid = t + (b - t) / 4;
			if (y_ > mid) y_ = mid;
		}
		@Override
		protected void onMeasure(int wspec, int hspec) {
			setMeasuredDimension(View.MeasureSpec.getSize(wspec), View.MeasureSpec.getSize(hspec));
		}
		void setSize(int x, int y, int w, int h) {
			x_ = x - 5;
			y_ = y - 5;
			w_ = w + 10;
			h_ = h + 10;
			super.onLayout(true, x_, y_, x_ + w_, y_ + h_);
		}
		int x_, y_, w_, h_;
	}

	public void initSDL()
	{
		if(sdlInited_)
			return;
		System.out.println("libSDL: Initializing video and SDL application");
		sdlInited_ = true;
		videoLayout_.removeView(layout_);
		layout_ = null;
		layout2_ = null;
		btn_ = null;
		tv_ = null;

		mGLView = new DemoGLSurfaceView(this);
		mGLView.setFocusableInTouchMode(true);
		mGLView.setFocusable(true);
		mGLView.requestFocus();

		videoLayout_ = new FrameLayout(this);
		setContentView(videoLayout_);

		videoLayout_.addView(mGLView);


		final Window window = getWindow();

		mGLView.nativeMouse(0, 0, 1, 0, 1000, 1000);
	}

	@Override
	protected void onPause() {
		if( downloader != null ) {
			synchronized( downloader ) {
				downloader.setStatusField(null);
			}
		}
		isPaused_ = true;
		if( mGLView != null )
			mGLView.onPause();
		super.onPause();
	}

	@Override
	protected void onResume() {
		super.onResume();
		if( mGLView != null )
			mGLView.onResume();
		else
		if( downloader != null ) {
			synchronized( downloader ) {
				downloader.setStatusField(tv_);
				if( downloader.DownloadComplete )
					initSDL();
			}
		}
		isPaused_ = false;
	}
	
	public boolean isPaused()
	{
		return isPaused_;
	}

	@Override
	protected void onDestroy() 
	{
		if( downloader != null ) {
			synchronized( downloader ) {
				downloader.setStatusField(null);
			}
		}
		if( mGLView != null )
			mGLView.exitApp();
		super.onDestroy();
		System.exit(0);
	}

	public void hideScreenKeyboard(int k)
	{
		if (!keyboardVisible_)
			throw new AssertionError();

		InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
		imm.hideSoftInputFromWindow(textField_.getWindowToken(), 0);
		keyboardVisible_ = false;

		textField_.clearFocus();
		videoLayout_.removeView(textField_);
		mGLView.requestFocus();

		synchronized(textInput)
		{
			String text = textField_.getText().toString();
			for(int i = 0; i < text.length(); i++)
			{
				DemoRenderer.nativeTextInput( (int)text.charAt(i), (int)text.codePointAt(i) );
			}
		}
		DemoRenderer.nativeTextInputFinished(k);
		mGLView.nativeMouse(0, 0, 1, 0, 0, 0);
	};
	
	public void showScreenKeyboard(final String oldText, int x, int y, int w, int h, boolean hide)
	{
		if (keyboardVisible_)
			throw new AssertionError();
		keyboardVisible_ = true;

		textField_ = new WesnothEditText(this);
		textField_.setSize(x, y, w, h);
		textField_.setText(oldText);
		textField_.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);

		videoLayout_.addView(textField_);

		getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
		textField_.setVisibility(View.VISIBLE);
		textField_.requestFocus();

		textField_.setOnEditorActionListener(new TextView.OnEditorActionListener() {
			@Override
			public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
				hideScreenKeyboard(1);
				return true;
			}
		});
		
	};

	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event) {
		//Log.w("Main", "onKeyDown(" + keyCode + ", " + event.toString() + ") " + keyboardVisible_);
		// Overrides Back key to use in our app
		if(keyboardVisible_) {
			textField_.onKeyDown(keyCode, event);
		} else if( mGLView != null ) {
			 mGLView.nativeKey( keyCode, 1 );
		} else if( keyCode == KeyEvent.KEYCODE_BACK && downloader != null )
		{ 
			if( downloader.DownloadFailed )
				System.exit(1);
			if( !downloader.DownloadComplete )
			 onStop();
		}
		return true;
	}
	
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event) {
		//Log.w("Main", "onKeyUp(" + keyCode + ", " + event.toString() + ") " + keyboardVisible_);
		if(keyboardVisible_) {
			textField_.onKeyUp(keyCode, event);
		} else if( mGLView != null ) {
			mGLView.nativeKey( keyCode, 0 );
		}
		return true;
	}
	
	@Override
	public boolean dispatchTouchEvent(final MotionEvent ev) {
		//System.out.println("Main::dispatchTouchEvent(" + ev.toString() + ")");
		if(keyboardVisible_) {
			textField_.dispatchTouchEvent(ev);
		} else if(mGLView != null) {
			mGLView.onTouchEvent(ev);
		} else if( btn_ != null ) {
			return btn_.dispatchTouchEvent(ev);
		}
		return true;
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		super.onConfigurationChanged(newConfig);
		// Do nothing here
	}
	
	public void setText(final String t)
	{
		class Callback implements Runnable
		{
			MainActivity Parent;
			public SpannedString text;
			public void run()
			{
				Parent.setUpStatusLabel();
				if(Parent.tv_ != null)
					Parent.tv_.setText(text);
			}
		}
		Callback cb = new Callback();
		cb.text = new SpannedString(t);
		cb.Parent = this;
		this.runOnUiThread(cb);
	}

	public void showTaskbarNotification()
	{
		showTaskbarNotification("SDL application paused", "SDL application", "Application is paused, click to activate");
	}

	// Stolen from SDL port by Mamaich
	public void showTaskbarNotification(String text0, String text1, String text2)
	{
		NotificationManager NotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		Intent intent = new Intent(this, MainActivity.class);
		PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, Intent.FLAG_ACTIVITY_NEW_TASK);
		Notification n = new Notification(R.drawable.icon, text0, System.currentTimeMillis());
		n.setLatestEventInfo(this, text1, text2, pendingIntent);
		NotificationManager.notify(NOTIFY_ID, n);
	}

	public void hideTaskbarNotification()
	{
		NotificationManager NotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		NotificationManager.cancel(NOTIFY_ID);
	}
	
	public void LoadLibraries()
	{
		try
		{
			for(String l : Globals.AppLibraries)
			{
				try
				{
					String libname = System.mapLibraryName(l);
					String filename = getFilesDir().getAbsolutePath();
					filename = filename + "/../lib/";
					filename = filename + libname;
					File libpath = new File(filename);
					System.out.println("libSDL.M: loading lib " + libpath.getAbsolutePath());
					System.load(libpath.getPath());
				}
				catch( UnsatisfiedLinkError e )
				{
					System.loadLibrary(l);
				}
			}
		}
		catch ( UnsatisfiedLinkError e )
		{
			try {
				System.out.println("libSDL: Extracting APP2SD-ed libs");
				
				InputStream in = null;
				try
				{
					for( int i = 0; ; i++ )
					{
						InputStream in2 = getAssets().open("bindata" + String.valueOf(i));
						if( in == null )
							in = in2;
						else
							in = new SequenceInputStream( in, in2 );
					}
				}
				catch( IOException ee ) { }

				if( in == null )
					throw new RuntimeException("libSDL: Extracting APP2SD-ed libs failed, the .apk file packaged incorrectly");

				ZipInputStream zip = new ZipInputStream(in);

				File cacheDir = getCacheDir();
				try {
					cacheDir.mkdirs();
				} catch( SecurityException ee ) { };
				
				byte[] buf = new byte[16384];
				while(true)
				{
					ZipEntry entry = null;
					entry = zip.getNextEntry();
					/*
					if( entry != null )
						System.out.println("Extracting lib " + entry.getName());
					*/
					if( entry == null )
					{
						System.out.println("Extracting libs finished");
						break;
					}
					if( entry.isDirectory() )
					{
						System.out.println("Warning '" + entry.getName() + "' is a directory");
						continue;
					}

					OutputStream out = null;
					String path = cacheDir.getAbsolutePath() + "/" + entry.getName();

					System.out.println("Saving to file '" + path + "'");

					out = new FileOutputStream( path );
					int len = zip.read(buf);
					while (len >= 0)
					{
						if(len > 0)
							out.write(buf, 0, len);
						len = zip.read(buf);
					}

					out.flush();
					out.close();
				}

				for(String l : Globals.AppLibraries)
				{
					String libname = System.mapLibraryName(l);
					File libpath = new File(cacheDir, libname);
					System.out.println("libSDL: loading lib " + libpath.getPath());
					System.load(libpath.getPath());
					libpath.delete();
				}
			}
			catch ( Exception ee )
			{
				System.out.println("libSDL: Error: " + ee.toString());
			}
		}
	};

	public ViewGroup getVideoLayout() { return videoLayout_; }

	static int NOTIFY_ID = 12367098; // Random ID

	private static DemoGLSurfaceView mGLView = null;
	private static AudioThread mAudioThread = null;
	private static DataDownloader downloader = null;

	private TextView tv_ = null;
	private Button btn_ = null;
	private LinearLayout layout_ = null;
	private LinearLayout layout2_ = null;

	private ViewGroup videoLayout_ = null;
	public WesnothEditText textField_ = null;
	private boolean sdlInited_ = false;
	boolean isPaused_ = false;
	boolean keyboardVisible_ = false;

	public LinkedList<Integer> textInput = new LinkedList<Integer> ();

}
